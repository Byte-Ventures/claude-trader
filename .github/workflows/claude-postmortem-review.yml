name: Claude Post-Mortem Review

on:
  repository_dispatch:
    types: [postmortem-review]

jobs:
  review-postmortem:
    runs-on: ubuntu-latest
    timeout-minutes: 15

    concurrency:
      group: postmortem-review
      cancel-in-progress: false

    permissions:
      contents: read
      discussions: read
      issues: write
      id-token: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: develop

      - name: Analyze post-mortem with Claude
        id: analyze
        uses: anthropics/claude-code-action@v1
        with:
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          prompt: |
            Analyze this post-mortem discussion and determine if it contains valid, implementable fixes.

            ## Discussion Details
            **Title:** ${{ github.event.client_payload.title }}
            **URL:** ${{ github.event.client_payload.discussion_url }}

            **Body:**
            ${{ github.event.client_payload.body }}

            ## Your Task

            1. **Extract proposed fixes** from the Claude analysis section
            2. **Verify each fix is:**
               - Specific and actionable (not vague)
               - Safe (won't break trading logic or introduce bugs)
               - Reasonable (makes sense given the analysis)
               - Implementable (can be done with code/config changes)

            3. **For valid fixes, output JSON:**
            ```json
            {
              "has_valid_fixes": true,
              "fixes": [
                {
                  "type": "config|code|threshold",
                  "description": "Brief description",
                  "details": "Specific implementation details",
                  "risk": "low|medium|high"
                }
              ],
              "issue_title": "Suggested issue title",
              "issue_body": "Detailed issue body with implementation steps"
            }
            ```

            4. **If no valid fixes, output:**
            ```json
            {
              "has_valid_fixes": false,
              "reason": "Why no fixes are actionable"
            }
            ```

            **Safety Rules:**
            - Reject fixes that modify core safety systems without justification
            - Reject fixes that remove error handling or validation
            - Reject vague suggestions like "improve performance"
            - Only accept fixes with clear, specific implementation paths

            Output ONLY the JSON, no other text.
          claude_args: >-
            --max-turns 10
            --allowed-tools "Read,Glob,Grep"
            --json-schema '{"type":"object","properties":{"has_valid_fixes":{"type":"boolean"},"fixes":{"type":"array"},"issue_title":{"type":"string"},"issue_body":{"type":"string"},"reason":{"type":"string"}},"required":["has_valid_fixes"]}'

      - name: Parse analysis result
        id: parse
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');

            // Try structured_output first, fall back to execution_file
            let output = `${{ steps.analyze.outputs.structured_output }}`;

            if (!output || output.trim() === '') {
              // Read from execution file
              const execFile = `${{ steps.analyze.outputs.execution_file }}`;
              if (execFile && fs.existsSync(execFile)) {
                const execData = JSON.parse(fs.readFileSync(execFile, 'utf8'));
                // Find the last assistant message with text content
                for (let i = execData.length - 1; i >= 0; i--) {
                  const msg = execData[i];
                  if (msg.type === 'assistant' && msg.message?.content) {
                    for (const block of msg.message.content) {
                      if (block.type === 'text') {
                        output = block.text;
                        break;
                      }
                    }
                    if (output) break;
                  }
                }
              }
            }

            // Extract JSON from response
            const jsonMatch = output ? output.match(/\{[\s\S]*\}/) : null;
            if (!jsonMatch) {
              core.setOutput('has_fixes', 'false');
              core.setOutput('reason', 'Could not parse analysis output');
              return;
            }

            try {
              const result = JSON.parse(jsonMatch[0]);

              // Validate required fields for valid fixes
              if (result.has_valid_fixes) {
                if (!result.issue_title || typeof result.issue_title !== 'string') {
                  core.setOutput('has_fixes', 'false');
                  core.setOutput('reason', 'Invalid output: missing issue_title');
                  return;
                }
                if (!result.issue_body || typeof result.issue_body !== 'string') {
                  core.setOutput('has_fixes', 'false');
                  core.setOutput('reason', 'Invalid output: missing issue_body');
                  return;
                }
                if (!Array.isArray(result.fixes) || result.fixes.length === 0) {
                  core.setOutput('has_fixes', 'false');
                  core.setOutput('reason', 'Invalid output: fixes must be non-empty array');
                  return;
                }
                // Truncate to prevent abuse
                const title = result.issue_title.substring(0, 200);
                const body = result.issue_body.substring(0, 10000);
                core.setOutput('has_fixes', 'true');
                core.setOutput('issue_title', title);
                core.setOutput('issue_body', body);
                core.setOutput('fixes', JSON.stringify(result.fixes));
              } else {
                core.setOutput('has_fixes', 'false');
                core.setOutput('reason', result.reason || 'No valid fixes found');
              }
            } catch (e) {
              core.setOutput('has_fixes', 'false');
              core.setOutput('reason', `JSON parse error: ${e.message}`);
            }

      - name: Create issue with auto-fix label
        if: steps.parse.outputs.has_fixes == 'true'
        uses: actions/github-script@v7
        env:
          ISSUE_TITLE: ${{ steps.parse.outputs.issue_title }}
          ISSUE_BODY: ${{ steps.parse.outputs.issue_body }}
          DISCUSSION_URL: ${{ github.event.client_payload.discussion_url }}
        with:
          script: |
            const header = "## Auto-generated from Post-Mortem Analysis\n\n**Source Discussion:** " + process.env.DISCUSSION_URL + "\n\n---\n\n";
            const footer = "\n\n---\n\n*This issue was automatically created from post-mortem analysis.*\n*The `auto-fix` label will trigger automatic fix attempt.*";
            const body = header + process.env.ISSUE_BODY + footer;

            const issue = await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: process.env.ISSUE_TITLE,
              body: body,
              labels: ['auto-fix', 'post-mortem']
            });

            console.log("Created issue #" + issue.data.number + ": " + issue.data.html_url);

      - name: Log result
        if: always()
        run: |
          echo "Post-mortem review completed"
          echo "Has fixes: ${{ steps.parse.outputs.has_fixes }}"
          if [ "${{ steps.parse.outputs.has_fixes }}" != "true" ]; then
            echo "Reason: ${{ steps.parse.outputs.reason }}"
          fi
