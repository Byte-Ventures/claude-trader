name: Claude Post-Mortem Review

on:
  repository_dispatch:
    types: [postmortem-review]

jobs:
  review-postmortem:
    runs-on: ubuntu-latest
    timeout-minutes: 15

    concurrency:
      group: postmortem-review
      cancel-in-progress: false

    permissions:
      contents: read
      discussions: read
      issues: write
      id-token: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: develop

      - name: Analyze post-mortem with Claude
        id: analyze
        uses: anthropics/claude-code-action@v1
        with:
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          prompt: |
            Analyze this post-mortem discussion and determine if it contains valid, implementable fixes.

            ## Discussion Details
            **Title:** ${{ github.event.client_payload.title }}
            **URL:** ${{ github.event.client_payload.discussion_url }}

            **Body:**
            ${{ github.event.client_payload.body }}

            ## Your Task

            1. **Extract proposed fixes** from the Claude analysis section
            2. **Verify each fix is:**
               - Specific and actionable (not vague)
               - Safe (won't break trading logic or introduce bugs)
               - Reasonable (makes sense given the analysis)
               - Implementable (can be done with code/config changes)

            3. **For valid fixes, output JSON with SEPARATE issue for each fix:**
            ```json
            {
              "has_valid_fixes": true,
              "fixes": [
                {
                  "type": "config|code|threshold",
                  "priority": "high|medium|low",
                  "risk": "low|medium|high",
                  "issue_title": "Short, specific title for THIS fix only",
                  "issue_body": "Detailed implementation steps for THIS fix only"
                }
              ]
            }
            ```

            **IMPORTANT**: Each fix gets its own issue. Keep each issue_body focused on ONE change only.
            - issue_title: Brief, actionable (e.g., "Increase MIN_STOP_LOSS_PERCENT to 2.5%")
            - issue_body: Implementation details for that single fix

            4. **If no valid fixes, output:**
            ```json
            {
              "has_valid_fixes": false,
              "reason": "Why no fixes are actionable"
            }
            ```

            **Safety Rules:**
            - Reject fixes that modify core safety systems without justification
            - Reject fixes that remove error handling or validation
            - Reject vague suggestions like "improve performance"
            - Only accept fixes with clear, specific implementation paths

            Output ONLY the JSON, no other text.
          claude_args: >-
            --max-turns 10
            --allowed-tools "Read,Glob,Grep"

      - name: Parse analysis result
        id: parse
        uses: actions/github-script@v7
        env:
          STRUCTURED_OUTPUT: ${{ steps.analyze.outputs.structured_output }}
          EXECUTION_FILE: ${{ steps.analyze.outputs.execution_file }}
        with:
          script: |
            const fs = require('fs');

            // Try structured_output first, fall back to execution_file
            let output = process.env.STRUCTURED_OUTPUT || '';

            if (!output.trim()) {
              // Read from execution file
              const execFile = process.env.EXECUTION_FILE || '';
              if (execFile && fs.existsSync(execFile)) {
                const execData = JSON.parse(fs.readFileSync(execFile, 'utf8'));
                // Find the last assistant message with text content
                for (let i = execData.length - 1; i >= 0; i--) {
                  const msg = execData[i];
                  if (msg.type === 'assistant' && msg.message?.content) {
                    for (const block of msg.message.content) {
                      if (block.type === 'text') {
                        output = block.text;
                        break;
                      }
                    }
                    if (output) break;
                  }
                }
              }
            }

            // Extract JSON from response
            const jsonMatch = output ? output.match(/\{[\s\S]*\}/) : null;
            if (!jsonMatch) {
              core.setOutput('has_fixes', 'false');
              core.setOutput('reason', 'Could not parse analysis output');
              return;
            }

            try {
              const result = JSON.parse(jsonMatch[0]);

              // Validate required fields for valid fixes
              if (result.has_valid_fixes) {
                if (!Array.isArray(result.fixes) || result.fixes.length === 0) {
                  core.setOutput('has_fixes', 'false');
                  core.setOutput('reason', 'Invalid output: fixes must be non-empty array');
                  return;
                }
                // Validate each fix has required fields
                for (const fix of result.fixes) {
                  if (!fix.issue_title || !fix.issue_body) {
                    core.setOutput('has_fixes', 'false');
                    core.setOutput('reason', 'Invalid output: each fix must have issue_title and issue_body');
                    return;
                  }
                }
                // Truncate each fix to prevent abuse
                const fixes = result.fixes.map(fix => ({
                  ...fix,
                  issue_title: fix.issue_title.substring(0, 200),
                  issue_body: fix.issue_body.substring(0, 8000)
                }));
                core.setOutput('has_fixes', 'true');
                core.setOutput('fixes', JSON.stringify(fixes));
                core.setOutput('fix_count', fixes.length.toString());
              } else {
                core.setOutput('has_fixes', 'false');
                core.setOutput('reason', result.reason || 'No valid fixes found');
              }
            } catch (e) {
              core.setOutput('has_fixes', 'false');
              core.setOutput('reason', `JSON parse error: ${e.message}`);
            }

      - name: Create issues for each fix
        if: steps.parse.outputs.has_fixes == 'true'
        uses: actions/github-script@v7
        env:
          FIXES_JSON: ${{ steps.parse.outputs.fixes }}
          DISCUSSION_URL: ${{ github.event.client_payload.discussion_url }}
        with:
          script: |
            const fixes = JSON.parse(process.env.FIXES_JSON);
            const discussionUrl = process.env.DISCUSSION_URL;

            // Get existing open issues to check for duplicates
            const { data: existingIssues } = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              labels: 'post-mortem',
              per_page: 100
            });

            const existingTitles = existingIssues.map(i => i.title.toLowerCase());

            let created = 0;
            let skipped = 0;

            for (const fix of fixes) {
              // Check for duplicate (case-insensitive title match)
              const isDuplicate = existingTitles.some(t =>
                t.includes(fix.issue_title.toLowerCase()) ||
                fix.issue_title.toLowerCase().includes(t)
              );

              if (isDuplicate) {
                console.log("Skipping duplicate: " + fix.issue_title);
                skipped++;
                continue;
              }

              const header = "## Auto-generated from Post-Mortem Analysis\n\n" +
                "**Source Discussion:** " + discussionUrl + "\n" +
                "**Priority:** " + (fix.priority || "medium") + "\n" +
                "**Risk:** " + (fix.risk || "low") + "\n\n---\n\n";
              const footer = "\n\n---\n\n*This issue was automatically created from post-mortem analysis.*\n" +
                "*The `auto-fix` label will trigger automatic fix attempt.*";
              const body = header + fix.issue_body + footer;

              const issue = await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: fix.issue_title,
                body: body,
                labels: ['auto-fix', 'post-mortem']
              });

              console.log("Created issue #" + issue.data.number + ": " + issue.data.html_url);

              // Trigger auto-fix workflow via repository_dispatch
              // (GITHUB_TOKEN events don't trigger workflows, so we use dispatch)
              await github.rest.repos.createDispatchEvent({
                owner: context.repo.owner,
                repo: context.repo.repo,
                event_type: 'auto-fix-issue',
                client_payload: { issue_number: issue.data.number }
              });
              console.log("Dispatched auto-fix for issue #" + issue.data.number);

              created++;

              // Small delay to avoid rate limiting
              await new Promise(r => setTimeout(r, 2000));
            }

            console.log("Summary: Created " + created + " issues, dispatched " + created + " auto-fix workflows, skipped " + skipped + " duplicates");

      - name: Log result
        if: always()
        run: |
          echo "Post-mortem review completed"
          echo "Has fixes: ${{ steps.parse.outputs.has_fixes }}"
          if [ "${{ steps.parse.outputs.has_fixes }}" != "true" ]; then
            echo "Reason: ${{ steps.parse.outputs.reason }}"
          fi
