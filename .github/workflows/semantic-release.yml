name: Semantic Release

on:
  push:
    branches:
      - main

permissions:
  contents: read

jobs:
  release:
    # Skip if this is a release commit (prevents infinite loop)
    if: "!startsWith(github.event.head_commit.message, 'chore(release):')"
    runs-on: ubuntu-latest
    concurrency:
      group: semantic-release
      cancel-in-progress: false

    permissions:
      contents: write
      pull-requests: write

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.10'

      - name: Install semantic-release
        run: pip install python-semantic-release

      - name: Configure Git
        run: |
          git config user.name "claude[bot]"
          git config user.email "noreply@anthropic.com"

      - name: Calculate next version
        id: version
        run: |
          # Get next version without making changes
          OUTPUT=$(semantic-release version --print 2>&1) || true

          # Check if semantic-release says no release needed
          if echo "$OUTPUT" | grep -q "No release will be made"; then
            echo "has_release=false" >> $GITHUB_OUTPUT
            echo "No release needed - version already released"
            exit 0
          fi

          VERSION=$(echo "$OUTPUT" | grep -oP '^\d+\.\d+\.\d+$' | tail -1)
          if [ -n "$VERSION" ]; then
            echo "next=$VERSION" >> $GITHUB_OUTPUT
            echo "has_release=true" >> $GITHUB_OUTPUT
            echo "Next version: $VERSION"
          else
            echo "has_release=false" >> $GITHUB_OUTPUT
            echo "No release needed"
            # Log warning if output suggests there should have been a version
            if echo "$OUTPUT" | grep -q "bump"; then
              echo "::warning::Version parsing may have failed. Output: $OUTPUT"
            fi
          fi

      - name: Create release branch and PR
        if: steps.version.outputs.has_release == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -e  # Exit on any error

          VERSION="${{ steps.version.outputs.next }}"
          BRANCH="release/v${VERSION}"

          # Validate VERSION is set and looks like a semver
          if [ -z "$VERSION" ] || ! echo "$VERSION" | grep -qE '^[0-9]+\.[0-9]+\.[0-9]+$'; then
            echo "::error::Invalid or empty VERSION: '$VERSION'"
            exit 1
          fi

          # Delete branch if it exists from a previous failed run
          if git show-ref --verify --quiet refs/heads/"$BRANCH"; then
            echo "::warning::Branch $BRANCH already exists, deleting and recreating"
            git branch -D "$BRANCH"
          fi
          if git ls-remote --exit-code --heads origin "$BRANCH" >/dev/null 2>&1; then
            echo "::warning::Remote branch $BRANCH exists, deleting"
            git push origin --delete "$BRANCH"
          fi

          # Create release branch
          git checkout -b "$BRANCH"

          # Manually update version file
          # Note: semantic-release won't update files on non-release branches,
          # so we do it manually. The version was already calculated above.
          sed -i "s/^__version__ = .*/__version__ = \"${VERSION}\"/" src/version.py

          # Validate the version was actually updated
          if ! grep -q "^__version__ = \"${VERSION}\"" src/version.py; then
            echo "::error::Failed to update src/version.py to version ${VERSION}"
            cat src/version.py
            exit 1
          fi

          # Generate minimal changelog entry (full details in GitHub release)
          DATE=$(date +%Y-%m-%d)
          REPO_URL="${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY}"

          CHANGELOG_ENTRY=$(printf "## v%s (%s)\n\nSee [GitHub Release](%s/releases/tag/v%s) for details.\n" "$VERSION" "$DATE" "$REPO_URL" "$VERSION")

          # Update CHANGELOG.md - insert before first version entry (## v)
          if [ -f CHANGELOG.md ] && [ -s CHANGELOG.md ]; then
            if grep -q '^## v' CHANGELOG.md; then
              # Insert before first version entry
              awk -v entry="$CHANGELOG_ENTRY" '/^## v/ && !inserted {print entry; inserted=1} {print}' CHANGELOG.md > CHANGELOG.tmp
              mv CHANGELOG.tmp CHANGELOG.md
            else
              # No version entries - append to end of file
              echo "" >> CHANGELOG.md
              echo "$CHANGELOG_ENTRY" >> CHANGELOG.md
            fi
          else
            # File doesn't exist or is empty - create with standard header
            printf "# Changelog\n\nAll notable changes to this project will be documented in this file.\n\nThis file is automatically updated by semantic-release.\n\n" > CHANGELOG.md
            echo "$CHANGELOG_ENTRY" >> CHANGELOG.md
          fi

          # Stage changes and commit only if there are actual changes
          git add src/version.py CHANGELOG.md
          if ! git diff --cached --quiet; then
            git commit -m "chore(release): ${VERSION}"
          else
            echo "::error::No changes to commit - version may already be ${VERSION}"
            exit 1
          fi

          # Push the release branch
          git push origin "$BRANCH"

          # Create PR
          PR_BODY=$(printf "## Automated Release v%s\n\nThis PR was automatically created by semantic-release.\n\n**Changes:**\n- Version bump to %s\n- Updated CHANGELOG.md\n\nThis PR will be auto-merged once checks pass." "$VERSION" "$VERSION")
          if ! PR_URL=$(gh pr create --base main --head "$BRANCH" --title "chore(release): ${VERSION}" --body "$PR_BODY"); then
            echo "::error::Failed to create PR for release $VERSION"
            # Cleanup orphaned branch
            git push origin --delete "$BRANCH" 2>/dev/null || true
            exit 1
          fi

          echo "Created PR: $PR_URL"

          # Wait for GitHub to process the PR
          sleep 5

          # Merge the release PR directly
          if ! gh pr merge "$BRANCH" --squash --delete-branch; then
            echo "::error::Failed to merge release PR"
            echo "::notice::Manual merge required: $PR_URL"
            exit 1
          fi

          echo "::notice::Release PR merged: $PR_URL"

          # Switch to main and pull the merge commit
          # Wait for GitHub to propagate the merge
          sleep 5
          git checkout main
          git pull origin main

          # Validate we got the merged commit with the new version
          if ! grep -q "^__version__ = \"${VERSION}\"" src/version.py; then
            echo "::warning::Version mismatch, retrying pull..."
            sleep 5
            git pull origin main
            if ! grep -q "^__version__ = \"${VERSION}\"" src/version.py; then
              echo "::error::Main branch version mismatch after pull. Expected: ${VERSION}"
              exit 1
            fi
          fi

          # Create and push tag
          TAG="v${VERSION}"
          if git rev-parse "$TAG" >/dev/null 2>&1; then
            echo "Tag $TAG already exists, skipping"
          else
            git tag -a "$TAG" -m "Release $TAG"
            git push origin "$TAG"
            echo "Created tag: $TAG"
          fi

          # Create GitHub Release
          if gh release view "$TAG" >/dev/null 2>&1; then
            echo "Release $TAG already exists, skipping"
          else
            gh release create "$TAG" --title "Release $TAG" --generate-notes
            echo "::notice::Created GitHub Release: $TAG"
          fi
